#!/usr/bin/python3
import sys
import random
#sudo apt install  python3-wcwidth
import wcwidth
#wcwidth.wcswidth(text)
#constants
language="en"#eitehr jp or en
outputType="PT"#either "PT" for plain text or "HTML"
def count_lines(filepath):
    try:
        with open(filepath, 'r') as file:
            return sum(1 for line in file) + 1  # +2 to avoid EOF issues
    except FileNotFoundError:
        print(f"Error: The file '{filepath}' was not found.")
        return -1
    except Exception as e:
        print(f"An error occurred: {e}")
        return -1

class initGlobals:
    def __init__(self):
        self.fileLineCount = None
        self.slots = None
        self.buffer = None

class Line:
    def __init__(self):
        self.indentNumber = 0
        self.instruction = None
        self.parameters = None

def initCodeInfo(globals, fileName):
    globals.fileLineCount = count_lines(fileName)
    linesInfo = [Line() for _ in range(globals.fileLineCount)]
    return linesInfo

def readPythonFile(globals, boardFilename):
    currentLine = 1
    #print("reading python file...")
    try:
        with open(boardFilename, 'r', encoding='utf-8') as f:
            for line in f:
                if currentLine >= globals.fileLineCount:
                    break
                # Count leading spaces to determine indent level (4 spaces = 1 indent)
                indent_count = 0
                for char in line:
                    if char == " ":
                        indent_count += 1
                    else:
                        break
                globals.slots[currentLine].indentNumber = int(indent_count // 4)
                globals.slots[currentLine].instruction = line.strip()
                #print(f"Line {currentLine}, indent: {globals.slots[currentLine].indentNumber}, instruction: {globals.slots[currentLine].instruction}")
                currentLine += 1
            #print("EOF reached.")
    except FileNotFoundError:
        print("Error: The file was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")

def createoutputPT(globals): 
    output =""
    #output +='<output lang="jp">\n'
    #output +='<head>\n'
    #output +='    <meta charset="UTF-8">\n'
    #output +='</head>\n'
    #output +='<body style="background-color:powderblue;">\n'
    #print("creating output...")
    for currentLine in range(1, globals.fileLineCount):
        if not globals.slots[currentLine].instruction:
            #skip empty lines
            continue  
        first_character = globals.slots[currentLine].instruction[0]
        if first_character=="#":#this instruction is a comment
            rest_of_string = globals.slots[currentLine].instruction[1:]
            comment = rest_of_string
            output += " "+"_" * wcwidth.wcswidth(comment)
            output += newLine
            output += "/"+comment+"/"
            output += newLine
            output += " "+"-" * wcwidth.wcswidth(comment)
            output += newLine
            continue 
        # Get the first three characters
        first_three_chars = globals.slots[currentLine].instruction[:3]
        if first_three_chars=="def":#this instruction is a comment
            # Get the rest of the string
            rest_of_string = globals.slots[currentLine].instruction[3:]
            index_of_paren = rest_of_string.find('(')
            if index_of_paren != -1:
                functionName = rest_of_string[:index_of_paren]
                from_paren_onwards = rest_of_string[index_of_paren:]  # Fix: Use rest_of_string
                index_of_closing_paren = from_paren_onwards.find(')')
                if index_of_closing_paren == -1:
                    # If no parenthesis is found, the entire string is "before_paren"
                    sys.exit("Uneven parenthesys on line: " + str(currentLine))                
                else:
                    parameters = from_paren_onwards[1:index_of_closing_paren]
                if not parameters == "":
                    output += " "+"_" * wcwidth.wcswidth(constFunctDefFull + functionName + constFunctParamsSimplified + parameters)
                    output += newLine
                    output += "| "
                    output += constFunctDefFull+functionName
                    output += constFunctParamsSimplified + parameters
                    output += " |"
                    output += newLine
                    output += " "+"-" * wcwidth.wcswidth(constFunctDefFull + functionName + constFunctParamsSimplified + parameters)
                    output += newLine
                    continue
                else:
                    output += " "+"_" * wcwidth.wcswidth(constFunctDefFull + functionName)
                    output += newLine
                    output += "| "
                    output += constFunctDefFull+functionName
                    output += " |"
                    output += newLine
                    output += " "+"-" * wcwidth.wcswidth(constFunctDefFull + functionName)
                    output += newLine
                    continue
            else:
                # If no parenthesis is found, the entire string is "before_paren"
                sys.exit("error while parsing python file, open parenthesis not found after function name on line: " + str(currentLine))
        first_three_chars = globals.slots[currentLine].instruction[:3]
        if first_three_chars=="if ":#this instruction is a comment
            #rest_of_string = globals.slots[currentLine].instruction[3:]
            simplifiedAndTrsanlsated = globals.slots[currentLine].instruction.replace(":", " then ")
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constIf, constIfSimple)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constThen, "")
            if language=="jp":
                if constNot in simplifiedAndTrsanlsated:#if it contains "not"
                    simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constNot, "")
                    simplifiedAndTrsanlsated = simplifiedAndTrsanlsated+constNotSimple
                    simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constThen, constThenSimple)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constTurtleDir, constTurtleDirSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constEQ, constEQSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constTurtleUp, constTurtleUpSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constTurtleLeft, constTurtleLeftSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constTurtleRight, constTurtleRightSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constTurtleDown, constTurtleDownSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constTurtleCanProceedFoward, constTurtleCanProceedFowardSimplified)
            simplifiedAndTrsanlsated = simplifiedAndTrsanlsated.replace(constAmILayingOnEgg, constAmILayingOnEggSimple)
            if language=="jp":
                simplifiedAndTrsanlsated = simplifiedAndTrsanlsated+constThenSimple
            else:
                simplifiedAndTrsanlsated = simplifiedAndTrsanlsated+" "+constThenSimple                 
            output += "     " * globals.slots[currentLine].indentNumber
            output += " "+"_" * wcwidth.wcswidth(" "+simplifiedAndTrsanlsated+" ")
            output += newLine
            output += "---->" * globals.slots[currentLine].indentNumber
            output += "| "
            output += simplifiedAndTrsanlsated
            output += " |"
            output += newLine
            output += "     " * globals.slots[currentLine].indentNumber
            output += " "+"-" * wcwidth.wcswidth(" "+simplifiedAndTrsanlsated+" ")
            output += newLine
            continue
        if globals.slots[currentLine].instruction.endswith(")"):
            # Get the rest of the string
            rest_of_string = globals.slots[currentLine].instruction
            index_of_paren = rest_of_string.find('(')
            if index_of_paren != -1:
                functionName = rest_of_string[:index_of_paren]
                if functionName==constFd:
                    functionName=constFdSimple
                if functionName==constRt:
                    functionName=constRtSimple
                if functionName==constLt:
                    functionName=constLtSimple
                if functionName==constLayEgg:
                    functionName=constLayEggSimple
                if functionName==constEnd:
                    functionName=constEndSimple
                from_paren_onwards = rest_of_string[index_of_paren:]  # Fix: Use rest_of_string
                index_of_closing_paren = from_paren_onwards.find(')')
                if index_of_closing_paren == -1:
                    # If no parenthesis is found, the entire string is "before_paren"
                    sys.exit("Uneven parenthesys on line: " + str(currentLine))                
                else:
                    index_of_closing_paren = globals.slots[currentLine].instruction.find(')')
                    parameters = globals.slots[currentLine].instruction[index_of_paren+1:index_of_closing_paren]
                    if language=="jp":
                        parameters = parameters.replace("H", "ボードの縦")
                        parameters = parameters.replace("W", "ボードの横")
                if not parameters == "":
                    output += "     " * globals.slots[currentLine].indentNumber
                    output += " "+"_" * wcwidth.wcswidth(constFunctCallFull + functionName + " "+constFunctParamsSimplified+" " + parameters)
                    output += newLine
                    output += "---->" * globals.slots[currentLine].indentNumber
                    output += "| "
                    output += constFunctCall+functionName
                    output += " "+constFunctParamsSimplified+" " + parameters
                    output += " |"
                    output += newLine
                    output += "     " * globals.slots[currentLine].indentNumber
                    output += " "+"-" * wcwidth.wcswidth(constFunctCallFull + functionName + " "+constFunctParamsSimplified+" " + parameters)
                    output += newLine
                    continue
                else:
                    output += "     " * globals.slots[currentLine].indentNumber
                    output += " "+"_" * wcwidth.wcswidth(constFunctCallFull + functionName)
                    output += newLine
                    output += "---->" * globals.slots[currentLine].indentNumber
                    output += "| "
                    output += constFunctCall+functionName
                    output += " |"
                    output += newLine
                    output += "     " * globals.slots[currentLine].indentNumber
                    output += " "+"-" * wcwidth.wcswidth(constFunctCallFull + functionName)
                    output += newLine
                    continue
        else:#case where no known instruction is found
            instruction = globals.slots[currentLine].instruction
            if language=="jp":
                instruction = instruction.replace("else:", "そうでなければ、次に")
                instruction = instruction.replace("return", "戻る")
            output += "     " * globals.slots[currentLine].indentNumber
            output += " "+"_" * wcwidth.wcswidth("  "+instruction+"  ")
            output += newLine
            output += "---->" * globals.slots[currentLine].indentNumber
            output += "| "
            output += " "+instruction+" "
            output += " |"
            output += newLine
            output += "     " * globals.slots[currentLine].indentNumber
            output += " "+"-" * wcwidth.wcswidth("  "+instruction+"  ")
            output += newLine
            continue
    #output +='</body></output>\n'
    print(output)

class Stack:
    def __init__(self):
        self._items = []

    def push(self, item):
        self._items.append(item)

    def pop(self):
        if not self.is_empty():
            return self._items.pop()
        else:
            return "Stack is empty"

    def peek(self):
        if not self.is_empty():
            return self._items[-1]
        else:
            return "Stack is empty"

    def is_empty(self):
        return len(self._items) == 0

    def size(self):
        return len(self._items)

def generate_random_hex_color():
  # Generate a random integer between 0 and 16777215 (0xFFFFFF)
  # This covers all possible 24-bit RGB colors.
  random_integer = random.randint(0, 0xFFFFFF)
  
  # Format the integer as a 6-digit hexadecimal string, prefixed with '#'
  # The ':06x' ensures it's zero-padded to 6 characters if needed.
  hex_color = '#{:06x}'.format(random_integer)
  return hex_color

def addLineNumber(currentLine,newLine):
    output1=""
    output1 += newLine
    output1 += '<p style="color:yellow;background-color: blue; display: inline; border: 2px solid black; padding: 2px;">'
    formatted_number = f"{currentLine:04d}"
    output1 += str(formatted_number)
    output1 += '</p>'
    return output1


def addOpenBlock(stackSize):
    colorNumber=stackSize % 7
    if colorNumber==6: 
        color="#FF0000"
    elif colorNumber==5: 
        color="#FFA500"
    elif colorNumber==4: 
        color="#FFFF00"
    elif colorNumber==3: 
        color="#008000"
    elif colorNumber==2: 
        color="#0000FF"
    elif colorNumber==1: 
        color="#4B0082"
    elif colorNumber==0: 
        color="#EE82EE"
    output=""
    #output += '<img src="TLAC_boardgame/img/HTMLstuff/blankSpacer.png">' * stackSize + '<div style="background-color: '+color+'; display: inline-block; border: 2px solid black; padding: 2px;">'
    output += '<div style="background-color: '+color+'; display: inline-block; border: 2px solid black; padding: 2px;">'
    return output

def addCloseBlock():
    output=""
    output += '</div>'
    return output

def createoutputHTML(globals):     
    indent_stack = Stack()
    output = "<!DOCTYPE html>"
    output += '<output lang="jp">\n'
    output += '<head>\n'
    output += '    <meta charset="UTF-8">\n'
    output += '</head>\n'
    output += '<body style="background-color:powderblue;">\n'

    for currentLine in range(1, globals.fileLineCount):    
        if not globals.slots[currentLine].instruction:
            output += addLineNumber(currentLine,newLine)
            continue  # Skip lines that dont correspond with a line in the instruction of hte slots
        first_character = globals.slots[currentLine].instruction[0]
        # Synchronize stack with current indentation level
        current_indent = globals.slots[currentLine].indentNumber
        while indent_stack.size() > current_indent:
            indent_stack.pop()
            output += addCloseBlock()
        while indent_stack.size() < current_indent:
            output += addOpenBlock(indent_stack.size())
            indent_stack.push(indent_stack.size() + 1)

        # Add line number
        output += addLineNumber(currentLine, newLine)

        if first_character == "#":
            # Handle comment
            rest_of_string = globals.slots[currentLine].instruction[1:]
            comment = rest_of_string
            output += '<p style="background-color: green; display: inline; border: 2px solid black; padding: 2px;">'
            output += comment
            output += '</p>'
            output += newLine
            continue 

        # Handle function definitions
        first_three_chars = globals.slots[currentLine].instruction[:3]
        if first_three_chars == "def":
            rest_of_string = globals.slots[currentLine].instruction[3:]
            index_of_paren = rest_of_string.find('(')
            if index_of_paren != -1:
                functionName = rest_of_string[:index_of_paren]
                from_paren_onwards = rest_of_string[index_of_paren:]
                index_of_closing_paren = from_paren_onwards.find(')')
                if index_of_closing_paren == -1:
                    sys.exit("Uneven parentheses on line: " + str(currentLine))                
                else:
                    parameters = from_paren_onwards[1:index_of_closing_paren]
                output += '<p style="background-color: yellow; display: inline; border: 2px solid black; padding: 2px;">'
                output += constFunctDefFull + functionName
                if parameters:
                    output += constFunctParamsSimplified + parameters
                output += '</p>'
                output += newLine
                continue
            else:
                sys.exit("Error while parsing python file, open parenthesis not found after function name on line: " + str(currentLine))

        # Handle if statements
        if first_three_chars == "if ":
            simplifiedAndTranslated = globals.slots[currentLine].instruction.replace(":", " then ")
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constIf, constIfSimple)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constThen, "")
            if language == "jp":
                if constNot in simplifiedAndTranslated:
                    simplifiedAndTranslated = simplifiedAndTranslated.replace(constNot, "")
                    simplifiedAndTranslated = simplifiedAndTranslated + constNotSimple
                    simplifiedAndTranslated = simplifiedAndTranslated.replace(constThen, constThenSimple)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constTurtleDir, constTurtleDirSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constEQ, constEQSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constTurtleUp, constTurtleUpSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constTurtleLeft, constTurtleLeftSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constTurtleRight, constTurtleRightSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constTurtleDown, constTurtleDownSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constTurtleCanProceedFoward, constTurtleCanProceedFowardSimplified)
            simplifiedAndTranslated = simplifiedAndTranslated.replace(constAmILayingOnEgg, constAmILayingOnEggSimple)
            if language == "jp":
                simplifiedAndTranslated += constThenSimple
            else:
                simplifiedAndTranslated += " " + constThenSimple                 
            output += '<img src="TLAC_boardgame/img/HTMLstuff/block.png">' * globals.slots[currentLine].indentNumber
            output += '<p style="background-color: yellow; display: inline; border: 2px solid black; padding: 2px;">'
            output += simplifiedAndTranslated
            output += "</p>"
            output += newLine
            continue

        # Handle function calls
        if globals.slots[currentLine].instruction.endswith(")"):
            rest_of_string = globals.slots[currentLine].instruction
            index_of_paren = rest_of_string.find('(')
            if index_of_paren != -1:
                functionName = rest_of_string[:index_of_paren]
                if functionName == constFd:
                    functionName = constFdSimple
                elif functionName == constRt:
                    functionName = constRtSimple
                elif functionName == constLt:
                    functionName = constLtSimple
                elif functionName == constLayEgg:
                    functionName = constLayEggSimple
                elif functionName == constEnd:
                    functionName = constEndSimple
                index_of_paren = globals.slots[currentLine].instruction.find('(')
                from_paren_onwards = globals.slots[currentLine].instruction[index_of_paren:]
                #print("from_paren_onwards;"+from_paren_onwards)
                index_of_closing_paren = from_paren_onwards.find(')')
                if index_of_closing_paren == -1:
                    sys.exit("Uneven parentheses on line: " + str(currentLine))                
                else:
                    #print("here123g index1:"+str(index_of_paren) +" index2:"+str(index_of_closing_paren))
                    parameters = from_paren_onwards[index_of_paren-1 :index_of_closing_paren]
                    #print("***parameters;"+parameters)
                    if language == "jp":
                        parameters = parameters.replace("H", "ボードの縦")
                        parameters = parameters.replace("W", "ボードの横")
                #print("hereABC"+parameters)
                output += '<img src="TLAC_boardgame/img/HTMLstuff/block.png">' * globals.slots[currentLine].indentNumber
                output += '<p style="background-color: yellow; display: inline; border: 2px solid black; padding: 2px;">'
                output += constFunctCall + functionName
                if parameters:
                    output += " " + constFunctParamsSimplified + " " + parameters
                output += "</p>"
                output += newLine
                continue

        # Handle other instructions (e.g., else, return)
        instruction = globals.slots[currentLine].instruction
        if language == "jp":
            instruction = instruction.replace("else:", "そうでなければ、次に")
            instruction = instruction.replace("return", "戻る")
        output += '<img src="TLAC_boardgame/img/HTMLstuff/block.png">' * globals.slots[currentLine].indentNumber
        output += '<p style="background-color: yellow; display: inline; border: 2px solid black; padding: 2px;">'
        output += " " + instruction + " "
        output += "</p>"
        output += newLine
        continue

    # Close any remaining open divs
    while not indent_stack.is_empty():
        indent_stack.pop()
        output += addCloseBlock()

    output += '</body></output>\n'
    print(output)

def error1quit():
    errorMessage="first parameter is the language, eihter en or jp.\n"
    errorMessage+="second parameter is the output type, either PT for plain text or HTML.\n"
    errorMessage+="the third parameter is the name of the python file to parse"
    errorMessage+="\n"
    errorMessage+="example usage: ./htmlifyer.py jp PT problem7-program-simplified.py"
    sys.exit(errorMessage)

# main
globals = initGlobals()
if len(sys.argv) < 4:
    error1quit()
else:
    if sys.argv[1] == "--help":
        error1quit()
    language=sys.argv[1]#eitehr jp or en
    if not (language=="jp" or language=="en"):
        sys.exit("Error in language parameter, try --help")
    else:
        if language=="en":
            constFunctCall="Function call "
            constFunctCallFull=" Function call "
            constFunctDef="Function definition"
            constFunctDefFull=" Function definition "
            constFd="fd"
            constFdSimple="Turtle Move Foward"
            constRt="rt"
            constRtSimple="Turn Turtle Right"
            constLt="lt"
            constLtSimple="Turn Turtle Left"
            constLayEgg="layEgg"
            constLayEggSimple="Turtle lays egg underneath itself"
            constEnd="end"
            constEndSimple="End Program"
            constIf="if"
            constIfSimple="if"
            constNot="not"
            constNotSimple="not"
            constThen="then"
            constThenSimple="then"
            constTurtleDir="turtledirection"
            constTurtleDirSimplified="Turtle Direction"
            constEQ="=="
            constEQSimplified="="
            constTurtleUp='"^"'
            constTurtleUpSimplified="Facing Up"
            constTurtleRight='">"'
            constTurtleRightSimplified="Facing Right"
            constTurtleLeft='"<"'
            constTurtleLeftSimplified="Facing Left"
            constTurtleDown='"V"'
            constTurtleDownSimplified="Facing Down"
            constTurtleCanProceedFoward="testIfICanProceed"
            constTurtleCanProceedFowardSimplified='"can Turtle proceed forward?"'
            constAmILayingOnEgg="amILayingOnAnEgg()"
            constAmILayingOnEggSimple='"is Turtle laying on an egg?"'
            constFunctParams="parameters:"
            constFunctParamsSimplified="parameters:"
        elif language=="jp":
            constFunctCall="関数を呼び出す: "
            constFunctCallFull=" 関数を呼び出す: "
            constFunctDef="Function definition"
            constFunctDefFull=" 関数定義: "
            constFd="fd"
            constFdSimple="亀さんが前に進む"
            constRt="rt"
            constRtSimple="亀さんが右に曲がる"
            constLt="lt"
            constLtSimple="亀さんが左に曲がる"
            constLayEgg="layEgg"
            constLayEggSimple="亀さんが自分の下に卵を生む"
            constAmILayingOnEgg="amILayingOnAnEgg()"
            constAmILayingOnEggSimple="「亀さんが卵の上に座ってる」"
            constEnd="end"
            constEndSimple="プログラム終了"
            constIf="if"
            constIfSimple="もし"
            constNot="not"
            constNotSimple="そうでなければ"
            constThen="then"
            constThenSimple="、次に"
            constTurtleDir="turtledirection"
            constTurtleDirSimplified="亀さんの向き"
            constEQ="=="
            constEQSimplified="＝"
            constTurtleUp='"^"'
            constTurtleUpSimplified="上"
            constTurtleRight='">"'
            constTurtleRightSimplified="右"
            constTurtleLeft='"<"'
            constTurtleLeftSimplified="左"
            constTurtleDown='"V"'
            constTurtleDownSimplified="下"
            constTurtleCanProceedFoward="testIfICanProceed"
            constTurtleCanProceedFowardSimplified="「亀さんが前に進められる」"
            constFunctParams="parameters:"
            constFunctParamsSimplified="引数："
    outputType=sys.argv[2]#either "PT" for plain text or "HTML"
    if not (outputType=="PT" or outputType=="HTML"):
        sys.exit("Error in output type parameter, try --help")
    fileName = sys.argv[3]
    globals.slots = initCodeInfo(globals, fileName)
    readPythonFile(globals, fileName)
    if outputType=="PT":
        newLine="\n"
        createoutputPT(globals)
    elif outputType=="HTML":
        newLine="<BR>\n"
        createoutputHTML(globals)
#(done)add else: and return; or just a kind of way to deal with everything else
#(dont settled for divs)try start ↘  end ↙
#bug parameters dont appear after fd(2) command
#generate graphica boards form programs instead of just text
#monospace font
"""
4:39 PM <GeDaMo> amigojapan: maybe draw more complex shapes like trees or houses
4:39 PM ⇐ duckito quit (~duckito@user/duckito) Ping timeout: 272 seconds
4:40 PM <amigojapan> GeDaMo: trees i like pine trees can be drawn algorithmically so that good but houses seem more like just arbitrary code
4:41 PM <GeDaMo> A simple house could be a triangle over a square
4:41 PM → duckito joined (~duckito@user/duckito)
4:41 PM <amigojapan> But yeah pyramid tree triangle sounds good
4:41 PM <GeDaMo> Maybe add door and windows
4:41 PM <amigojapan> Ok
4:42 PM → merijn joined (~merijn@host-vr.cgnat-g.v4.dfn.nl)
4:42 PM <GeDaMo> Drawing multiple copies of the same shape would show code reuse
4:43 PM <amigojapan> I see GeDaMo . Like making a function good each shape i guess
4:43 PM <GeDaMo> Yes
4:43 PM <amigojapan> Nice
4:43 PM → valsinats joined  ⇐ mero quit  ↔ inkheart nipped out  
4:45 PM <amigojapan> GeDaMo: maybe i can also teach my "8 basics of programming"like i did in this tutorial https://amigojapan.github.io/8_basics_of_programming/8_basics_of_programming_python3_new.html
4:45 PM → jab416171 joined (~jab416171@user/jab416171)
4:46 PM <GeDaMo> Yeah
4:46 PM <amigojapan> Thanks
4:46 PM → xtvl, alius, nitrix_ and indigaz28 joined  ⇐ Square, CrimeWave, random_name_e352, pifon4 and nitrix quit  ↔ darkos_cpp popped in  ↔ merijn, inkheart and yitz nipped out  
4:58 PM <amigojapan> GeDaMo: but this time I will delve onto how to implement control struictures like while , do until and for
4:59 PM ⇐ merijn and indigaz2 quit  •  indigaz28 → indigaz2  
5:00 PM <amigojapan> GeDaMo: oh yeah and travelling thur a maze\
5:01 PM <amigojapan> traversing mazes
5:02 PM ⇐ blahboybaz quit (uid693214@id-693214.tinside.irccloud.com) Quit: Connection closed for inactivity

next chapter 
amigojapan> GeDaMo: I think the turtle library for python may be useful too,  but one thing I don't like in it, is that they added some timming stuff so that the renedrring the image takes a while , but I think that is bad for very complex images, maybe there is some way to disactivate it?
5:10 PM <GeDaMo> Possibly
5:10 PM <amigojapan> i hope so
5:10 PM → merijn joined  ⇐ Pink3 and jtj quit  
5:12 PM <amigojapan> GeDaMo: I foudn trying to teach my wife to draw some basic kanji in LOGO seemed to be fun for her
5:13 PM <GeDaMo> :)
5:14 PM ⇐ Guest75 and f11 quit  
5:15 PM <amigojapan> GeDaMo: some kanji like 口　川　山　木　品　唱
5:15 PM <GeDaMo> Yeah
next few chapters
go back from HTML program charts to text program charts and then to real python code. do the same stuff
"""